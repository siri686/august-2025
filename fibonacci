#fibonacci using recursive 
def fibo(n):
    if(n==0):
        return 0
    if(n==1):
        return 1

    return fibo(n-1)+fibo(n-2)

n=int(input())
print(fibo(n))


# fibonacci using dynamic programming (memorization)
def fibo(n,dp): #T.C:-O(N) S.C:-O(n)+O(N) [O(n)--recursion sum]
    if(n==0):
        return 0
    if(n==1):
        return 1
    if(dp[n]==-1):
        dp[n]=fibo(n-1,dp)+fibo(n-2,dp)
    return dp[n]
n=int(input())
dp=[-1]*(n+1)
print(fibo(n,dp))


#fibonacci using tabulation (dp)
def fibo(n,dp):
    dp[0]=0
    dp[1]=1
    for index in range(2,n+1): #T.C:-O(N)
        dp[index]=dp[index-1]+dp[index-2]
    return dp[n]
n=int(input())
dp=[-1]*(n+1) #S.C:-O(N)
print(fibo(n,dp))


#fibonacci using space optimization (dp)
def fibo(n):
    prev2=0
    prev=1
    for i in range(2,n+1): #T.C:-O(N)
        curr=prev2+prev #S.C :-O(N)
        prev2=prev
        prev=curr
    return prev
n=int(input())
print(fibo(n))
